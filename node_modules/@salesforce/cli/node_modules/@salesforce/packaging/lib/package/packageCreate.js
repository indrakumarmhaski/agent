"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPackage = exports.createPackageDirEntry = exports.createPackageRequestFromContext = void 0;
const core_1 = require("@salesforce/core");
const kit_1 = require("@salesforce/kit");
const pkgUtils = require("../utils/packageUtils");
const packageUtils_1 = require("../utils/packageUtils");
function createPackageRequestFromContext(project, options) {
    const namespace = options.noNamespace ? '' : project.getSfProjectJson().getContents().namespace ?? '';
    return {
        Name: options.name,
        Description: options.description,
        NamespacePrefix: namespace,
        ContainerOptions: options.packageType,
        IsOrgDependent: options.orgDependent,
        PackageErrorUsername: options.errorNotificationUsername,
    };
}
exports.createPackageRequestFromContext = createPackageRequestFromContext;
/**
 * Create packageDirectory json entry for this package that can be written to sfdx-project.json
 *
 * @param project
 * @param options - package create options
 * @private
 */
function createPackageDirEntry(project, options) {
    const packageDirs = project.getSfProjectJson().getContents().packageDirectories ?? [];
    let isNew = false;
    // see if package exists (exists means it has an id or package)
    let packageDir = packageDirs
        .map((pd) => pd)
        .find((pd) => pd.path === options.path && !pd.id && !pd.package);
    if (!packageDir) {
        // no match - create a new one
        isNew = true;
        packageDir = { ...pkgUtils.DEFAULT_PACKAGE_DIR };
        packageDir.path = (0, packageUtils_1.replaceIfEmpty)(packageDir.path, options.path);
    }
    if (packageDirs.length === 0) {
        packageDir.default = true;
    }
    else if (isNew) {
        packageDir.default = !packageDirs.find((pd) => pd.default);
    }
    packageDir.package = (0, packageUtils_1.replaceIfEmpty)(packageDir.package, options.name);
    packageDir.versionName = (0, packageUtils_1.replaceIfEmpty)(packageDir.versionName, pkgUtils.DEFAULT_PACKAGE_DIR.versionName);
    packageDir.versionNumber = (0, packageUtils_1.replaceIfEmpty)(packageDir.versionNumber, pkgUtils.DEFAULT_PACKAGE_DIR.versionNumber);
    packageDir.versionDescription = (0, packageUtils_1.replaceIfEmpty)(packageDir.versionDescription, options.description);
    return packageDir;
}
exports.createPackageDirEntry = createPackageDirEntry;
async function createPackage(connection, project, options) {
    // strip trailing slash from path param
    options.path = options.path.replace(/\/$/, '');
    const request = createPackageRequestFromContext(project, options);
    const createResult = await connection.tooling
        .sobject('Package2')
        .create(request)
        .catch((err) => {
        const error = err instanceof Error ? err : new Error(typeof err === 'string' ? err : 'Unknown error');
        throw core_1.SfError.wrap((0, packageUtils_1.applyErrorAction)((0, packageUtils_1.massageErrorMessage)(error)));
    });
    if (!createResult.success) {
        throw pkgUtils.combineSaveErrors('Package2', 'create', createResult.errors);
    }
    if (!kit_1.env.getBoolean('SF_PROJECT_AUTOUPDATE_DISABLE_FOR_PACKAGE_CREATE')) {
        const packageDirectory = createPackageDirEntry(project, options);
        project.getSfProjectJson().addPackageDirectory(packageDirectory);
        project.getSfProjectJson().addPackageAlias(options.name, createResult.id);
        await project.getSfProjectJson().write();
    }
    return { Id: createResult.id };
}
exports.createPackage = createPackage;
//# sourceMappingURL=packageCreate.js.map