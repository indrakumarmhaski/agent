"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestService = void 0;
const types_1 = require("./types");
const path_1 = require("path");
const i18n_1 = require("../i18n");
const reporters_1 = require("../reporters");
const utils_1 = require("./utils");
const fileSystemHandler_1 = require("../utils/fileSystemHandler");
const asyncTests_1 = require("./asyncTests");
const syncTests_1 = require("./syncTests");
const diagnosticUtil_1 = require("./diagnosticUtil");
const elapsedTime_1 = require("../utils/elapsedTime");
class TestService {
    connection;
    asyncService;
    syncService;
    constructor(connection) {
        this.connection = connection;
        this.syncService = new syncTests_1.SyncTests(connection);
        this.asyncService = new asyncTests_1.AsyncTests(connection);
    }
    /**
     * Retrieve all suites in org
     * @returns list of Suites in org
     */
    async retrieveAllSuites() {
        const testSuiteRecords = (await this.connection.tooling.query(`SELECT id, TestSuiteName FROM ApexTestSuite`));
        return testSuiteRecords.records;
    }
    async retrieveSuiteId(suitename) {
        const suiteResult = (await this.connection.tooling.query(`SELECT id FROM ApexTestSuite WHERE TestSuiteName = '${suitename}'`));
        if (suiteResult.records.length === 0) {
            return undefined;
        }
        return suiteResult.records[0].Id;
    }
    /**
     * Retrive the ids for the given suites
     * @param suitenames names of suites
     * @returns Ids associated with each suite
     */
    async getOrCreateSuiteIds(suitenames) {
        const suiteIds = suitenames.map(async (suite) => {
            const suiteId = await this.retrieveSuiteId(suite);
            if (suiteId === undefined) {
                const result = (await this.connection.tooling.create('ApexTestSuite', {
                    TestSuiteName: suite
                }));
                return result.id;
            }
            return suiteId;
        });
        return await Promise.all(suiteIds);
    }
    /**
     * Retrieves the test classes in a given suite
     * @param suitename name of suite
     * @param suiteId id of suite
     * @returns list of test classes in the suite
     */
    async getTestsInSuite(suitename, suiteId) {
        if (suitename === undefined && suiteId === undefined) {
            throw new Error(i18n_1.nls.localize('suitenameErr'));
        }
        if (suitename) {
            suiteId = await this.retrieveSuiteId(suitename);
            if (suiteId === undefined) {
                throw new Error(i18n_1.nls.localize('missingSuiteErr'));
            }
        }
        const classRecords = (await this.connection.tooling.query(`SELECT ApexClassId FROM TestSuiteMembership WHERE ApexTestSuiteId = '${suiteId}'`));
        return classRecords.records;
    }
    /**
     * Returns the associated Ids for each given Apex class
     * @param testClasses list of Apex class names
     * @returns the associated ids for each Apex class
     */
    async getApexClassIds(testClasses) {
        const classIds = testClasses.map(async (testClass) => {
            const apexClass = (await this.connection.tooling.query(`SELECT id, name FROM ApexClass WHERE Name = '${testClass}'`));
            if (apexClass.records.length === 0) {
                throw new Error(i18n_1.nls.localize('missingTestClassErr', testClass));
            }
            return apexClass.records[0].Id;
        });
        return await Promise.all(classIds);
    }
    /**
     * Builds a test suite with the given test classes. Creates the test suite if it doesn't exist already
     * @param suitename name of suite
     * @param tests tests to be added to suite
     */
    async buildSuite(suitename, testClasses) {
        const testSuiteId = (await this.getOrCreateSuiteIds([suitename]))[0];
        const classesInSuite = await this.getTestsInSuite(undefined, testSuiteId);
        const testClassIds = await this.getApexClassIds(testClasses);
        await Promise.all(testClassIds.map(async (classId) => {
            const existingClass = classesInSuite.filter((rec) => rec.ApexClassId === classId);
            const testClass = testClasses[testClassIds.indexOf(classId)];
            if (existingClass.length > 0) {
                console.log(i18n_1.nls.localize('testSuiteMsg', [testClass, suitename]));
            }
            else {
                await this.connection.tooling.create('TestSuiteMembership', {
                    ApexClassId: classId,
                    ApexTestSuiteId: testSuiteId
                });
                console.log(i18n_1.nls.localize('classSuiteMsg', [testClass, suitename]));
            }
        }));
    }
    /**
     * Synchronous Test Runs
     * @param options Synchronous Test Runs configuration
     * @param codeCoverage should report code coverage
     * @param token cancellation token
     */
    async runTestSynchronous(options, codeCoverage = false, token) {
        return await this.syncService.runTests(options, codeCoverage, token);
    }
    /**
     * Asynchronous Test Runs
     * @param options test options
     * @param codeCoverage should report code coverage
     * @param immediatelyReturn should not wait for test run to complete, return test run id immediately
     * @param progress progress reporter
     * @param token cancellation token
     */
    async runTestAsynchronous(options, codeCoverage = false, immediatelyReturn = false, progress, token) {
        return await this.asyncService.runTests(options, codeCoverage, immediatelyReturn, progress, token);
    }
    /**
     * Report Asynchronous Test Run Results
     * @param testRunId test run id
     * @param codeCoverage should report code coverages
     * @param token cancellation token
     */
    async reportAsyncResults(testRunId, codeCoverage = false, token) {
        return await this.asyncService.reportAsyncResults(testRunId, codeCoverage, token);
    }
    /**
     *
     * @param result test result
     * @param outputDirConfig config for result files
     * @param codeCoverage should report code coverage
     * @returns list of result files created
     */
    async writeResultFiles(result, outputDirConfig, codeCoverage = false) {
        const { dirPath, resultFormats, fileInfos } = outputDirConfig;
        const fileMap = [];
        const testRunId = result.hasOwnProperty('summary')
            ? result.summary.testRunId
            : result.testRunId;
        fileMap.push({
            path: (0, path_1.join)(dirPath, 'test-run-id.txt'),
            content: testRunId
        });
        if (resultFormats) {
            if (!result.hasOwnProperty('summary')) {
                throw new Error(i18n_1.nls.localize('runIdFormatErr'));
            }
            result = result;
            for (const format of resultFormats) {
                if (!(format in types_1.ResultFormat)) {
                    throw new Error(i18n_1.nls.localize('resultFormatErr'));
                }
                switch (format) {
                    case types_1.ResultFormat.json:
                        fileMap.push({
                            path: (0, path_1.join)(dirPath, testRunId ? `test-result-${testRunId}.json` : `test-result.json`),
                            content: (0, utils_1.stringify)(result)
                        });
                        break;
                    case types_1.ResultFormat.tap:
                        const tapResult = new reporters_1.TapReporter().format(result);
                        fileMap.push({
                            path: (0, path_1.join)(dirPath, `test-result-${testRunId}-tap.txt`),
                            content: tapResult
                        });
                        break;
                    case types_1.ResultFormat.junit:
                        const junitResult = new reporters_1.JUnitReporter().format(result);
                        fileMap.push({
                            path: (0, path_1.join)(dirPath, testRunId
                                ? `test-result-${testRunId}-junit.xml`
                                : `test-result-junit.xml`),
                            content: junitResult
                        });
                        break;
                }
            }
        }
        if (codeCoverage) {
            if (!result.hasOwnProperty('summary')) {
                throw new Error(i18n_1.nls.localize('covIdFormatErr'));
            }
            result = result;
            const coverageRecords = result.tests.map((record) => {
                return record.perClassCoverage;
            });
            fileMap.push({
                path: (0, path_1.join)(dirPath, `test-result-${testRunId}-codecoverage.json`),
                content: (0, utils_1.stringify)(coverageRecords)
            });
        }
        fileInfos?.forEach((fileInfo) => {
            fileMap.push({
                path: (0, path_1.join)(dirPath, fileInfo.filename),
                content: typeof fileInfo.content !== 'string'
                    ? (0, utils_1.stringify)(fileInfo.content)
                    : fileInfo.content
            });
        });
        (0, fileSystemHandler_1.createFiles)(fileMap);
        return fileMap.map((file) => {
            return file.path;
        });
    }
    // utils to build test run payloads that may contain namespaces
    async buildSyncPayload(testLevel, tests, classnames) {
        try {
            if (tests) {
                const payload = await this.buildTestPayload(tests);
                const classes = payload.tests?.map((testItem) => {
                    if (testItem.className) {
                        return testItem.className;
                    }
                });
                if (new Set(classes).size !== 1) {
                    throw new Error(i18n_1.nls.localize('syncClassErr'));
                }
                return payload;
            }
            else if (classnames) {
                const prop = (0, utils_1.isValidApexClassID)(classnames) ? 'classId' : 'className';
                return {
                    tests: [{ [prop]: classnames }],
                    testLevel
                };
            }
            throw new Error(i18n_1.nls.localize('payloadErr'));
        }
        catch (e) {
            throw (0, diagnosticUtil_1.formatTestErrors)(e);
        }
    }
    async buildAsyncPayload(testLevel, tests, classNames, suiteNames) {
        try {
            if (tests) {
                return (await this.buildTestPayload(tests));
            }
            else if (classNames) {
                return await this.buildAsyncClassPayload(classNames);
            }
            else {
                return {
                    suiteNames,
                    testLevel
                };
            }
        }
        catch (e) {
            throw (0, diagnosticUtil_1.formatTestErrors)(e);
        }
    }
    async buildAsyncClassPayload(classNames) {
        const classNameArray = classNames.split(',');
        const classItems = classNameArray.map((item) => {
            const classParts = item.split('.');
            if (classParts.length > 1) {
                return {
                    className: `${classParts[0]}.${classParts[1]}`
                };
            }
            const prop = (0, utils_1.isValidApexClassID)(item) ? 'classId' : 'className';
            return { [prop]: item };
        });
        return { tests: classItems, testLevel: "RunSpecifiedTests" /* TestLevel.RunSpecifiedTests */ };
    }
    async buildTestPayload(testNames) {
        const testNameArray = testNames.split(',');
        const testItems = [];
        const classes = [];
        let namespaceInfos;
        for (const test of testNameArray) {
            if (test.indexOf('.') > 0) {
                const testParts = test.split('.');
                if (testParts.length === 3) {
                    if (!classes.includes(testParts[1])) {
                        testItems.push({
                            namespace: `${testParts[0]}`,
                            className: `${testParts[1]}`,
                            testMethods: [testParts[2]]
                        });
                        classes.push(testParts[1]);
                    }
                    else {
                        testItems.forEach((element) => {
                            if (element.className === `${testParts[1]}`) {
                                element.namespace = `${testParts[0]}`;
                                element.testMethods.push(`${testParts[2]}`);
                            }
                        });
                    }
                }
                else {
                    if (typeof namespaceInfos === 'undefined') {
                        namespaceInfos = await (0, utils_1.queryNamespaces)(this.connection);
                    }
                    const currentNamespace = namespaceInfos.find((namespaceInfo) => namespaceInfo.namespace === testParts[0]);
                    // NOTE: Installed packages require the namespace to be specified as part of the className field
                    // The namespace field should not be used with subscriber orgs
                    if (currentNamespace) {
                        if (currentNamespace.installedNs) {
                            testItems.push({
                                className: `${testParts[0]}.${testParts[1]}`
                            });
                        }
                        else {
                            testItems.push({
                                namespace: `${testParts[0]}`,
                                className: `${testParts[1]}`
                            });
                        }
                    }
                    else {
                        if (!classes.includes(testParts[0])) {
                            testItems.push({
                                className: testParts[0],
                                testMethods: [testParts[1]]
                            });
                            classes.push(testParts[0]);
                        }
                        else {
                            testItems.forEach((element) => {
                                if (element.className === testParts[0]) {
                                    element.testMethods.push(testParts[1]);
                                }
                            });
                        }
                    }
                }
            }
            else {
                const prop = (0, utils_1.isValidApexClassID)(test) ? 'classId' : 'className';
                testItems.push({ [prop]: test });
            }
        }
        return {
            tests: testItems,
            testLevel: "RunSpecifiedTests" /* TestLevel.RunSpecifiedTests */
        };
    }
}
exports.TestService = TestService;
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "retrieveAllSuites", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "retrieveSuiteId", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "getOrCreateSuiteIds", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "getTestsInSuite", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "getApexClassIds", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "buildSuite", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "runTestSynchronous", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "runTestAsynchronous", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "reportAsyncResults", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "writeResultFiles", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "buildSyncPayload", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "buildAsyncPayload", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "buildAsyncClassPayload", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], TestService.prototype, "buildTestPayload", null);
//# sourceMappingURL=testService.js.map