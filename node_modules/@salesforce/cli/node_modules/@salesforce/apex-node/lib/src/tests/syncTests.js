"use strict";
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncTests = void 0;
const utils_1 = require("../utils");
const codeCoverage_1 = require("./codeCoverage");
const diagnosticUtil_1 = require("./diagnosticUtil");
const utils_2 = require("./utils");
const elapsedTime_1 = require("../utils/elapsedTime");
class SyncTests {
    connection;
    codecoverage;
    constructor(connection) {
        this.connection = connection;
        this.codecoverage = new codeCoverage_1.CodeCoverage(this.connection);
    }
    /**
     * Synchronous Test Runs
     * @param options Synchronous Test Runs configuration
     * @param codeCoverage should report code coverage
     * @param token cancellation token
     */
    async runTests(options, codeCoverage = false, token) {
        try {
            const url = `${this.connection.tooling._baseUrl()}/runTestsSynchronous`;
            const request = {
                method: 'POST',
                url,
                body: JSON.stringify(options),
                headers: { 'content-type': 'application/json' }
            };
            const testRun = (await this.connection.tooling.request(request));
            if (token && token.isCancellationRequested) {
                return null;
            }
            return await this.formatSyncResults(testRun, (0, utils_1.getCurrentTime)(), codeCoverage);
        }
        catch (e) {
            throw (0, diagnosticUtil_1.formatTestErrors)(e);
        }
    }
    async formatSyncResults(apiTestResult, startTime, codeCoverage = false) {
        const coveredApexClassIdSet = new Set();
        const { apexTestClassIdSet, testResults } = this.buildSyncTestResults(apiTestResult);
        const globalTestFailed = apiTestResult.failures.length;
        const globalTestPassed = apiTestResult.successes.length;
        const result = {
            summary: {
                outcome: globalTestFailed === 0
                    ? "Passed" /* ApexTestRunResultStatus.Passed */
                    : "Failed" /* ApexTestRunResultStatus.Failed */,
                testsRan: apiTestResult.numTestsRun,
                passing: globalTestPassed,
                failing: globalTestFailed,
                skipped: 0,
                passRate: (0, utils_2.calculatePercentage)(globalTestPassed, apiTestResult.numTestsRun),
                failRate: (0, utils_2.calculatePercentage)(globalTestFailed, apiTestResult.numTestsRun),
                skipRate: (0, utils_2.calculatePercentage)(0, apiTestResult.numTestsRun),
                testStartTime: (0, utils_1.formatStartTime)(startTime, 'ISO'),
                testExecutionTimeInMs: apiTestResult.totalTime ?? 0,
                testTotalTimeInMs: apiTestResult.totalTime ?? 0,
                commandTimeInMs: (0, utils_1.getCurrentTime)() - startTime,
                hostname: this.connection.instanceUrl,
                orgId: this.connection.getAuthInfoFields().orgId,
                username: this.connection.getUsername(),
                testRunId: '',
                userId: this.connection.getConnectionOptions().userId
            },
            tests: testResults
        };
        if (codeCoverage) {
            const perClassCovMap = await this.codecoverage.getPerClassCodeCoverage(apexTestClassIdSet);
            if (perClassCovMap.size > 0) {
                result.tests.forEach((item) => {
                    const keyCodeCov = `${item.apexClass.id}-${item.methodName}`;
                    const perClassCov = perClassCovMap.get(keyCodeCov);
                    if (perClassCov) {
                        perClassCov.forEach((classCov) => coveredApexClassIdSet.add(classCov.apexClassOrTriggerId));
                        item.perClassCoverage = perClassCov;
                    }
                });
            }
            const { codeCoverageResults, totalLines, coveredLines } = await this.codecoverage.getAggregateCodeCoverage(coveredApexClassIdSet);
            result.codecoverage = codeCoverageResults;
            result.summary.totalLines = totalLines;
            result.summary.coveredLines = coveredLines;
            result.summary.testRunCoverage = (0, utils_2.calculatePercentage)(coveredLines, totalLines);
            result.summary.orgWideCoverage =
                await this.codecoverage.getOrgWideCoverage();
        }
        return result;
    }
    buildSyncTestResults(apiTestResult) {
        const testResults = [];
        const apexTestClassIdSet = new Set();
        apiTestResult.successes.forEach((item) => {
            const nms = item.namespace ? `${item.namespace}.` : '';
            apexTestClassIdSet.add(item.id);
            testResults.push({
                id: '',
                queueItemId: '',
                stackTrace: '',
                message: '',
                asyncApexJobId: '',
                methodName: item.methodName,
                outcome: "Pass" /* ApexTestResultOutcome.Pass */,
                apexLogId: apiTestResult.apexLogId,
                apexClass: {
                    id: item.id,
                    name: item.name,
                    namespacePrefix: item.namespace,
                    fullName: `${nms}${item.name}`
                },
                runTime: item.time ?? 0,
                testTimestamp: '',
                fullName: `${nms}${item.name}.${item.methodName}`
            });
        });
        apiTestResult.failures.forEach((item) => {
            const nms = item.namespace ? `${item.namespace}__` : '';
            apexTestClassIdSet.add(item.id);
            const diagnostic = item.message || item.stackTrace ? (0, diagnosticUtil_1.getSyncDiagnostic)(item) : null;
            testResults.push({
                id: '',
                queueItemId: '',
                stackTrace: item.stackTrace,
                message: item.message,
                asyncApexJobId: '',
                methodName: item.methodName,
                outcome: "Fail" /* ApexTestResultOutcome.Fail */,
                apexLogId: apiTestResult.apexLogId,
                apexClass: {
                    id: item.id,
                    name: item.name,
                    namespacePrefix: item.namespace,
                    fullName: `${nms}${item.name}`
                },
                runTime: item.time ?? 0,
                testTimestamp: '',
                fullName: `${nms}${item.name}.${item.methodName}`,
                ...(diagnostic ? { diagnostic } : {})
            });
        });
        return { apexTestClassIdSet, testResults };
    }
}
exports.SyncTests = SyncTests;
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], SyncTests.prototype, "runTests", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], SyncTests.prototype, "formatSyncResults", null);
__decorate([
    (0, elapsedTime_1.elapsedTime)()
], SyncTests.prototype, "buildSyncTestResults", null);
//# sourceMappingURL=syncTests.js.map