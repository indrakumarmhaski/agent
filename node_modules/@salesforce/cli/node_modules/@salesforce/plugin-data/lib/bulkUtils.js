/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Messages } from '@salesforce/core';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-data', 'messages');
const POLL_FREQUENCY_MS = 5000;
export const isBulkV2RequestDone = (jobInfo) => ['Aborted', 'Failed', 'JobComplete'].includes(jobInfo.state);
export const transformResults = (results) => ({
    successfulResults: results.successfulResults.map((record) => record),
    failedResults: results.failedResults.map((record) => record),
    unprocessedRecords: results.unprocessedRecords.map((record) => record),
});
export const validateSobjectType = async (sobjectType, connection) => {
    try {
        await connection.sobject(sobjectType).describe();
    }
    catch (e) {
        throw new Error(messages.getMessage('invalidSobject', [sobjectType, e.message]));
    }
};
export const waitOrTimeout = async (job, wait) => {
    if (wait > 0) {
        let waitCountDown = wait;
        const progress = setInterval(() => {
            const remainingTime = (waitCountDown -= POLL_FREQUENCY_MS);
            job.emit('jobProgress', { remainingTime, stage: 'polling' });
        }, POLL_FREQUENCY_MS);
        const timeout = setTimeout(() => {
            clearInterval(progress);
            job.emit('jobTimeout');
        }, wait ?? 0);
        try {
            await job.poll(POLL_FREQUENCY_MS, wait);
        }
        finally {
            clearInterval(progress);
            clearTimeout(timeout);
        }
    }
};
//# sourceMappingURL=bulkUtils.js.map