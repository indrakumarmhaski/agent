/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
import { Flags, loglevel, orgApiVersionFlagWithDeprecations, SfCommand } from '@salesforce/sf-plugins-core';
import { Messages } from '@salesforce/core';
import { Package } from '@salesforce/packaging';
import chalk from 'chalk';
import { requiredHubFlag } from '../../utils/hubFlag.js';
Messages.importMessagesDirectoryFromMetaUrl(import.meta.url);
const messages = Messages.loadMessages('@salesforce/plugin-packaging', 'package_list');
export class PackageListCommand extends SfCommand {
    static summary = messages.getMessage('summary');
    static description = messages.getMessage('description');
    static examples = messages.getMessages('examples');
    static requiresProject = true;
    static deprecateAliases = true;
    static aliases = ['force:package:list'];
    static flags = {
        loglevel,
        'target-dev-hub': requiredHubFlag,
        'api-version': orgApiVersionFlagWithDeprecations,
        verbose: Flags.boolean({
            summary: messages.getMessage('flags.verbose.summary'),
        }),
    };
    results = [];
    async run() {
        const { flags } = await this.parse(PackageListCommand);
        const connection = flags['target-dev-hub'].getConnection(flags['api-version']);
        const queryResult = await Package.list(connection);
        this.mapRecordsToResults(queryResult);
        this.displayResults(flags.verbose, connection.getApiVersion());
        return this.results;
    }
    mapRecordsToResults(records) {
        if (records && records.length > 0) {
            this.results = records
                .filter((record) => record.IsDeprecated === false)
                .map(({ Id, SubscriberPackageId, Name, Description, NamespacePrefix, ContainerOptions, ConvertedFromPackageId, IsOrgDependent, PackageErrorUsername, AppAnalyticsEnabled, CreatedById, }) => ({
                Id,
                SubscriberPackageId,
                Name,
                Description,
                NamespacePrefix,
                ContainerOptions,
                ConvertedFromPackageId,
                Alias: this.project.getAliasesFromPackageId(Id).join(),
                IsOrgDependent: ContainerOptions === 'Managed' ? 'N/A' : IsOrgDependent ? 'Yes' : 'No',
                PackageErrorUsername,
                AppAnalyticsEnabled,
                CreatedBy: CreatedById,
            }));
        }
    }
    displayResults(verbose = false, apiVersion) {
        this.styledHeader(chalk.blue(`Packages [${this.results.length}]`));
        const columns = {
            NamespacePrefix: { header: messages.getMessage('namespace') },
            Name: { header: messages.getMessage('name') },
            Id: { header: messages.getMessage('id') },
            Alias: { header: messages.getMessage('alias') },
            Description: { header: messages.getMessage('description') },
            ContainerOptions: {
                header: messages.getMessage('package-type'),
            },
        };
        if (verbose) {
            Object.assign(columns, {
                SubscriberPackageId: { header: messages.getMessage('package-id') },
                ConvertedFromPackageId: { header: messages.getMessage('convertedFromPackageId') },
                IsOrgDependent: { header: messages.getMessage('isOrgDependent') },
                PackageErrorUsername: { header: messages.getMessage('error-notification-username') },
            });
            if (apiVersion >= '59.0') {
                Object.assign(columns, {
                    AppAnalyticsEnabled: { header: messages.getMessage('app-analytics-enabled') },
                });
            }
            Object.assign(columns, {
                CreatedBy: {
                    header: messages.getMessage('createdBy'),
                },
            });
        }
        this.table(this.results, columns);
    }
}
//# sourceMappingURL=list.js.map